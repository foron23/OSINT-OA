# =============================================================================
# Telegram Listener - Telethon-based Implementation
# =============================================================================
"""
Telegram Message Listener using Telethon for real-time event handling.

This is a more robust replacement for the MCP-based polling approach:
- Uses Telethon's event system for real-time message handling
- No polling delay - messages are processed immediately
- Better error handling and automatic reconnection
- Native async support

Usage:
    listener = TelethonListener(target_dialog="cht[-123456]")
    listener.set_investigation_callback(my_callback)
    await listener.start()
"""

import asyncio
import logging
import os
import re
from datetime import datetime
from typing import Dict, Any, Optional, List, Set, Callable, Union

logger = logging.getLogger(__name__)

# Import Telethon with graceful fallback
try:
    from telethon import TelegramClient, events
    from telethon.tl.types import Message
    TELETHON_AVAILABLE = True
except ImportError:
    TELETHON_AVAILABLE = False
    logger.warning("Telethon not installed")

from integrations.telegram.telethon_client import (
    TelethonClient,
    TelethonConfig,
    TelegramFormatter,
    TelethonReportPublisher,
)


class TelethonListener:
    """
    Real-time Telegram message listener using Telethon events.
    
    Features:
    - Event-based message handling (no polling)
    - Command parsing
    - Natural language detection
    - Investigation triggering
    - Rich message formatting
    """
    
    def __init__(
        self,
        target_dialog: Optional[str] = None,
    ):
        """
        Initialize the listener.
        
        Args:
            target_dialog: Dialog ID to listen to (e.g., cht[-123456] or @username)
        """
        if not TELETHON_AVAILABLE:
            raise ImportError("Telethon required: pip install telethon")
        
        self.target_dialog = target_dialog or os.getenv("TELEGRAM_TARGET_DIALOG", "")
        self.logger = logging.getLogger(self.__class__.__name__)
        
        # Telethon client
        self.config = TelethonConfig.from_env()
        self._client: Optional[TelegramClient] = None
        self._target_entity = None
        self.formatter = TelegramFormatter()
        
        # State
        self.running = False
        self.processed_messages: Set[int] = set()
        
        # Investigation callback
        self._investigation_callback: Optional[Callable] = None
        
        # OSINT keywords for natural language detection
        self.osint_keywords = [
            'investiga', 'busca informaci√≥n', 'buscar', 'analiza',
            'investigate', 'search for', 'find info', 'analyze',
            'osint', 'threat intel', 'ciberamenaza', 'ransomware',
            'vulnerabilidad', 'cve', 'malware', 'apt', 'phishing'
        ]
        
        # Bot message patterns to ignore
        self._bot_patterns = [
            r'^üîç\s*<b>',           # Report headers
            r'^üìä\s*<b>',           # Status messages
            r'^üìã\s*<b>',           # List messages
            r'^‚úÖ\s*<b>',           # Success messages
            r'^‚ùå\s*<b>',           # Error messages
            r'^‚ö†Ô∏è\s*<b>',           # Warning messages
            r'^üî¨\s*<b>',           # Trace messages
            r'Generated by OSINT',  # Footer
        ]
    
    def set_investigation_callback(self, callback: Callable):
        """
        Set the callback for running investigations.
        
        Args:
            callback: Async function(query: str, requester: str, depth: str) -> Dict
        """
        self._investigation_callback = callback
    
    async def start(self):
        """Start the listener with event handlers."""
        if not self.target_dialog:
            self.logger.error("No target dialog configured. Set TELEGRAM_TARGET_DIALOG.")
            return
        
        self.running = True
        await self._log_startup_banner()
        
        try:
            # Initialize Telethon client
            self._client = TelegramClient(
                self.config.session_file,
                self.config.api_id,
                self.config.api_hash,
                system_version=self.config.system_version,
            )
            
            await self._client.connect()
            
            if not await self._client.is_user_authorized():
                self.logger.error(
                    "Session not authorized. Run: python scripts/setup_telegram.py"
                )
                return
            
            # Resolve target entity
            self._target_entity = await self._resolve_dialog()
            if not self._target_entity:
                self.logger.error(f"Could not resolve dialog: {self.target_dialog}")
                return
            
            self.logger.info(f"‚úÖ Listening to: {self._target_entity.title if hasattr(self._target_entity, 'title') else self._target_entity}")
            
            # Register message handler
            @self._client.on(events.NewMessage(chats=self._target_entity))
            async def message_handler(event):
                if self.running:
                    await self._handle_message(event.message)
            
            # Keep running
            self.logger.info("ü§ñ Listener active. Press Ctrl+C to stop.")
            await self._client.run_until_disconnected()
            
        except KeyboardInterrupt:
            self.logger.info("\nüëã Listener stopped by user")
        except Exception as e:
            self.logger.error(f"Listener error: {e}")
            raise
        finally:
            self.running = False
            if self._client:
                await self._client.disconnect()
    
    def stop(self):
        """Stop the listener."""
        self.running = False
        self.logger.info("Listener stopping...")
    
    async def _resolve_dialog(self):
        """Resolve the target dialog to an entity."""
        try:
            identifier = self.target_dialog
            
            # Handle cht[id] format
            if identifier.startswith("cht["):
                match = re.match(r'cht\[(-?\d+)\]', identifier)
                if match:
                    identifier = int(match.group(1))
            
            # Handle @username
            elif identifier.startswith("@"):
                identifier = identifier[1:]
            
            return await self._client.get_entity(identifier)
            
        except Exception as e:
            self.logger.error(f"Failed to resolve dialog: {e}")
            return None
    
    async def _log_startup_banner(self):
        """Log startup information."""
        self.logger.info("=" * 60)
        self.logger.info("  OSINT Telegram Listener (Telethon)")
        self.logger.info("=" * 60)
        self.logger.info(f"Target Dialog: {self.target_dialog}")
        self.logger.info(f"Session: {self.config.session_file}")
        self.logger.info("=" * 60)
        self.logger.info("")
        self.logger.info("Supported commands:")
        self.logger.info("  /osint       - Start OSINT investigation")
        self.logger.info("  /search      - Quick search")
        self.logger.info("  /deep        - Deep investigation")
        self.logger.info("  /runs        - List recent runs")
        self.logger.info("  /run <id>    - View run details")
        self.logger.info("  /traces <id> - View execution traces")
        self.logger.info("  /status      - Bot status")
        self.logger.info("  /help        - Show help")
        self.logger.info("")
    
    async def _handle_message(self, message: Message):
        """Handle an incoming message."""
        # Skip already processed
        if message.id in self.processed_messages:
            return
        self.processed_messages.add(message.id)
        
        text = message.text or ""
        sender_id = message.sender_id
        
        # Skip empty messages
        if not text.strip():
            return
        
        # Skip our own messages
        if self._is_bot_message(text):
            return
        
        self.logger.info(f"New message from {sender_id}: {text[:80]}...")
        
        # Route to appropriate handler
        await self._route_message(text, str(sender_id))
    
    def _is_bot_message(self, text: str) -> bool:
        """Check if message is from this bot."""
        for pattern in self._bot_patterns:
            if re.search(pattern, text):
                return True
        return False
    
    async def _route_message(self, text: str, sender: str):
        """Route message to appropriate handler."""
        text_lower = text.lower().strip()
        
        # Command handlers
        if text_lower.startswith('/osint '):
            query = text[7:].strip()
            await self._start_investigation(query, sender, depth="standard")
        
        elif text_lower.startswith('/search '):
            query = text[8:].strip()
            await self._start_investigation(query, sender, depth="quick")
        
        elif text_lower.startswith('/deep '):
            query = text[6:].strip()
            await self._start_investigation(query, sender, depth="deep")
        
        elif text_lower.startswith('/runs'):
            await self._handle_list_runs(sender)
        
        elif text_lower.startswith('/run '):
            run_id_str = text[5:].strip()
            await self._handle_run_detail(run_id_str, sender)
        
        elif text_lower.startswith('/traces '):
            run_id_str = text[8:].strip()
            await self._handle_traces(run_id_str, sender)
        
        elif text_lower.startswith('/status'):
            await self._handle_status(sender)
        
        elif text_lower.startswith('/help'):
            await self._handle_help(sender)
        
        # Natural language detection
        elif self._is_osint_request(text):
            query = self._extract_query(text)
            if query:
                await self._start_investigation(query, sender, depth="standard")
    
    def _is_osint_request(self, text: str) -> bool:
        """Check if message is an OSINT request."""
        text_lower = text.lower()
        return any(kw in text_lower for kw in self.osint_keywords)
    
    def _extract_query(self, text: str) -> str:
        """Extract query from natural language request."""
        prefixes = [
            'investiga sobre', 'busca informaci√≥n sobre', 'analiza',
            'investigate', 'search for', 'find info about', 'analyze'
        ]
        
        for prefix in prefixes:
            if text.lower().startswith(prefix):
                return text[len(prefix):].strip()
        
        return text
    
    # =========================================================================
    # Command Handlers
    # =========================================================================
    
    async def _send_message(self, text: str, parse_mode: str = "html"):
        """Send a message to the target dialog."""
        try:
            await self._client.send_message(
                self._target_entity,
                text,
                parse_mode=parse_mode
            )
        except Exception as e:
            self.logger.error(f"Failed to send message: {e}")
    
    async def _handle_status(self, sender: str):
        """Handle /status command."""
        try:
            from agents.registry import AgentRegistry
            agents = AgentRegistry.list_available()
            available_count = len([a for a in agents if a.get('available')])
            total_count = len(agents)
        except Exception:
            available_count = "N/A"
            total_count = "N/A"
        
        message = self.formatter.format_status_message(
            agents_available=available_count,
            agents_total=total_count
        )
        await self._send_message(message)
    
    async def _handle_help(self, sender: str):
        """Handle /help command."""
        await self._send_message(self.formatter.format_help_message())
    
    async def _handle_list_runs(self, sender: str):
        """Handle /runs command."""
        try:
            from db import RunRepository
            
            runs = RunRepository.list_runs(limit=10)
            
            if not runs:
                await self._send_message(
                    "üìã <b>Recent Investigations</b>\n\n"
                    "<i>No investigations found.</i>\n\n"
                    "<i>Use <code>/osint &lt;topic&gt;</code> to start one.</i>"
                )
                return
            
            lines = ["üìã <b>Recent Investigations</b>\n"]
            
            status_emoji = {
                'completed': '‚úÖ',
                'failed': '‚ùå',
                'started': '‚è≥',
                'partial': '‚ö†Ô∏è'
            }
            
            for run in runs:
                emoji = status_emoji.get(run.status, '‚ùì')
                query_short = run.query[:30] + "..." if len(run.query) > 30 else run.query
                query_escaped = TelegramFormatter.escape_html(query_short)
                
                lines.append(
                    f"{emoji} <b>#{run.id}</b> - {query_escaped}\n"
                    f"   <i>{run.started_at[:16] if run.started_at else 'N/A'}</i>"
                )
            
            lines.append("\n<i>Use <code>/run &lt;id&gt;</code> for details.</i>")
            
            await self._send_message("\n".join(lines))
            
        except Exception as e:
            self.logger.error(f"Error listing runs: {e}")
            await self._send_message(f"‚ùå <b>Error:</b> {TelegramFormatter.escape_html(str(e))}")
    
    async def _handle_run_detail(self, run_id_str: str, sender: str):
        """Handle /run <id> command."""
        try:
            from db import RunRepository, ItemRepository, ReportRepository, TraceRepository
            
            run_id = int(run_id_str)
            run = RunRepository.get_by_id(run_id)
            
            if not run:
                await self._send_message(f"‚ùå Investigation #{run_id} not found.")
                return
            
            item_count = ItemRepository.count_by_run(run_id)
            trace_count = TraceRepository.count_by_run(run_id)
            report = ReportRepository.get_by_run_id(run_id)
            
            status_emoji = {
                'completed': '‚úÖ',
                'failed': '‚ùå',
                'started': '‚è≥',
                'partial': '‚ö†Ô∏è'
            }.get(run.status, '‚ùì')
            
            message = f"""üìä <b>Investigation #{run.id}</b>

<b>Query:</b> {TelegramFormatter.escape_html(run.query)}
<b>Status:</b> {status_emoji} {run.status}
<b>Started:</b> {run.started_at[:16] if run.started_at else 'N/A'}
<b>Finished:</b> {run.finished_at[:16] if run.finished_at else 'In progress'}

üìà <b>Metrics:</b>
  ‚Ä¢ Items found: {item_count}
  ‚Ä¢ Execution traces: {trace_count}
  ‚Ä¢ Report: {'‚úÖ Generated' if report else '‚ùå Not available'}
"""
            
            if report and report.summary:
                summary_short = report.summary[:300]
                if len(report.summary) > 300:
                    summary_short += "..."
                message += f"\n<b>üìù Summary:</b>\n<i>{TelegramFormatter.escape_html(summary_short)}</i>\n"
            
            message += f"\n<i>Use <code>/traces {run_id}</code> for execution details.</i>"
            
            await self._send_message(message)
            
        except ValueError:
            await self._send_message("‚ùå Invalid ID. Use: <code>/run &lt;number&gt;</code>")
        except Exception as e:
            self.logger.error(f"Error getting run detail: {e}")
            await self._send_message(f"‚ùå <b>Error:</b> {TelegramFormatter.escape_html(str(e))}")
    
    async def _handle_traces(self, run_id_str: str, sender: str):
        """Handle /traces <id> command."""
        try:
            from db import RunRepository, TraceRepository
            
            run_id = int(run_id_str)
            run = RunRepository.get_by_id(run_id)
            
            if not run:
                await self._send_message(f"‚ùå Investigation #{run_id} not found.")
                return
            
            summary = TraceRepository.get_evidence_summary(run_id)
            traces = TraceRepository.get_by_run_id(run_id, include_full_data=False)
            
            if not traces:
                await self._send_message(
                    f"üî¨ <b>Traces for Investigation #{run_id}</b>\n\n"
                    f"<i>No traces recorded for this investigation.</i>"
                )
                return
            
            total_duration = summary.get('total_duration_ms', 0)
            duration_str = f"{total_duration / 1000:.2f}s" if total_duration else 'N/A'
            avg_conf = summary.get('avg_confidence')
            conf_str = f"{avg_conf * 100:.0f}%" if avg_conf else 'N/A'
            
            message = f"""üî¨ <b>Traces for Investigation #{run_id}</b>

<b>üìä Summary:</b>
  ‚Ä¢ Total traces: {summary.get('total_traces', 0)}
  ‚Ä¢ Evidence found: {summary.get('total_evidence', 0)}
  ‚Ä¢ Completed: {summary.get('completed_traces', 0)}
  ‚Ä¢ Failed: {summary.get('failed_traces', 0)}
  ‚Ä¢ Total duration: {duration_str}
  ‚Ä¢ Avg confidence: {conf_str}

<b>üìã Timeline:</b>
"""
            
            type_icons = {
                'tool_call': 'üîß',
                'agent_action': 'ü§ñ',
                'llm_reasoning': 'üí≠',
                'decision': 'üéØ',
                'error': '‚ùå',
                'checkpoint': 'üìç'
            }
            
            status_icons = {
                'completed': '‚úÖ',
                'failed': '‚ùå',
                'running': '‚è≥',
                'pending': '‚è∏Ô∏è',
                'skipped': '‚è≠Ô∏è'
            }
            
            for i, trace in enumerate(traces[:10]):
                type_icon = type_icons.get(trace.trace_type, 'üìù')
                status_icon = status_icons.get(trace.status, '‚ùì')
                
                tool_or_agent = trace.tool_name or trace.agent_name or 'Unknown'
                tool_short = tool_or_agent[:20] + "..." if len(tool_or_agent) > 20 else tool_or_agent
                
                evidence_str = f"üìã{trace.evidence_count}" if trace.evidence_count > 0 else ""
                duration_str = f"‚è±Ô∏è{trace.duration_ms/1000:.1f}s" if trace.duration_ms else ""
                
                message += f"\n{i+1}. {type_icon} {status_icon} <b>{TelegramFormatter.escape_html(tool_short)}</b>"
                if evidence_str or duration_str:
                    message += f"\n   {evidence_str} {duration_str}"
            
            if len(traces) > 10:
                message += f"\n\n<i>...and {len(traces) - 10} more traces. See web interface for all.</i>"
            
            await self._send_message(message)
            
        except ValueError:
            await self._send_message("‚ùå Invalid ID. Use: <code>/traces &lt;number&gt;</code>")
        except Exception as e:
            self.logger.error(f"Error getting traces: {e}")
            await self._send_message(f"‚ùå <b>Error:</b> {TelegramFormatter.escape_html(str(e))}")
    
    async def _start_investigation(
        self,
        query: str,
        requester: str,
        depth: str = "standard"
    ):
        """Start an OSINT investigation."""
        self.logger.info(f"Starting {depth} investigation: {query} (by {requester})")
        
        from db import RunRepository, ReportRepository, Report
        
        # Create run record
        limit = {"quick": 10, "standard": 20, "deep": 50}.get(depth, 20)
        
        run_id = RunRepository.create(
            query=query,
            initiated_by=f"telegram:{requester}",
            limit_requested=limit,
            scope=None
        )
        
        self.logger.info(f"Created run #{run_id} for query: {query}")
        
        # Send acknowledgment
        depth_labels = {"quick": "Quick Search", "standard": "Standard Investigation", "deep": "Deep Investigation"}
        
        await self._send_message(
            f"üîç <b>Starting {depth_labels.get(depth, 'Investigation')}</b>\n\n"
            f"üÜî <b>Run ID:</b> <code>{run_id}</code>\n"
            f"üìù <b>Query:</b> <code>{TelegramFormatter.escape_html(query)}</code>\n"
            f"üë§ <b>Requested by:</b> {requester}\n"
            f"‚öôÔ∏è <b>Depth:</b> {depth}\n"
            f"‚è≥ <b>Status:</b> In progress...\n\n"
            f"<i>Use <code>/run {run_id}</code> to check status.</i>"
        )
        
        try:
            # Run investigation
            result = await self._run_investigation(
                query=query,
                requester=requester,
                run_id=run_id,
                depth=depth
            )
            
            if result.get('status') == 'completed':
                report_preview = result.get('report_preview', '')
                if len(report_preview) > 500:
                    report_preview = report_preview[:500] + "..."
                
                await self._send_message(
                    f"‚úÖ <b>Investigation #{run_id} Completed</b>\n\n"
                    f"üìù <b>Query:</b> <code>{TelegramFormatter.escape_html(query)}</code>\n"
                    f"üìä <b>Status:</b> Completed\n\n"
                    f"<b>üìã Summary:</b>\n{TelegramFormatter.escape_html(report_preview)}\n\n"
                    f"<i>Use <code>/run {run_id}</code> for full details.</i>\n"
                    f"<i>Use <code>/traces {run_id}</code> for execution traces.</i>"
                )
            else:
                error_msg = result.get('error', 'Unknown error')
                await self._send_message(
                    f"‚ö†Ô∏è <b>Investigation #{run_id} Partial</b>\n\n"
                    f"üìä <b>Status:</b> {result.get('status', 'unknown')}\n"
                    f"‚ùå <b>Error:</b> {TelegramFormatter.escape_html(error_msg)}\n\n"
                    f"<i>Use <code>/run {run_id}</code> for details.</i>"
                )
                
        except Exception as e:
            self.logger.error(f"Investigation failed: {e}")
            RunRepository.update_status(run_id, "failed", stats={"error": str(e)})
            
            await self._send_message(
                f"‚ùå <b>Error in Investigation #{run_id}</b>\n\n"
                f"<b>Error:</b> {TelegramFormatter.escape_html(str(e))}\n\n"
                f"<i>Try again later.</i>"
            )
    
    async def _run_investigation(
        self,
        query: str,
        requester: str,
        run_id: int,
        depth: str = "standard"
    ) -> Dict[str, Any]:
        """Run the investigation using ControlAgent."""
        from agents.control import ControlAgent
        from db import RunRepository, ReportRepository, Report
        
        try:
            control_agent = ControlAgent()
            
            self.logger.info(f"Running investigation #{run_id} with depth={depth}")
            result = await asyncio.to_thread(
                control_agent.investigate,
                topic=query,
                depth=depth,
                run_id=run_id
            )
            
            report_text = result.get("report", "")
            
            # Store report
            report_obj = Report(
                run_id=run_id,
                query=query,
                report=report_text,
                summary=f"Investigation: {query[:100]}"
            )
            report_id = ReportRepository.create(report_obj)
            self.logger.info(f"Stored report #{report_id} for run #{run_id}")
            
            # Publish formatted report
            if report_text:
                await self._publish_report(
                    report_text=report_text,
                    query=query,
                    run_id=run_id,
                    stats=result.get("evidence", {}).get("stats"),
                )
            
            # Update run status
            stats = {
                "depth": depth,
                "agents_used": result.get("metadata", {}).get("agents_used", "auto"),
                "initiated_by": f"telegram:{requester}",
                "telegram_published": True,
            }
            RunRepository.update_status(run_id, "completed", stats=stats)
            
            report_preview = report_text[:500] + "..." if len(report_text) > 500 else report_text
            
            return {
                "status": "completed",
                "run_id": run_id,
                "report_id": report_id,
                "report_preview": report_preview,
            }
            
        except Exception as e:
            self.logger.error(f"Investigation #{run_id} failed: {e}")
            RunRepository.update_status(run_id, "failed", stats={"error": str(e)})
            return {"status": "error", "run_id": run_id, "error": str(e)}
    
    async def _publish_report(
        self,
        report_text: str,
        query: str,
        run_id: int,
        stats: Optional[Dict[str, Any]] = None,
    ):
        """Publish formatted report to Telegram."""
        formatted = self.formatter.format_osint_report(
            report=report_text,
            query=query,
            run_id=run_id,
            stats=stats,
        )
        
        await self._send_message(formatted)
        self.logger.info(f"Published report for run #{run_id}")


# =============================================================================
# Entry Point
# =============================================================================

async def run_telethon_listener():
    """Run the Telethon-based listener."""
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    
    target_dialog = os.getenv("TELEGRAM_TARGET_DIALOG", "")
    
    if not target_dialog:
        logger.error("‚ùå TELEGRAM_TARGET_DIALOG must be set in .env")
        return
    
    logger.info(f"üöÄ Starting Telethon Listener for dialog: {target_dialog}")
    
    listener = TelethonListener(target_dialog=target_dialog)
    
    try:
        await listener.start()
    except KeyboardInterrupt:
        logger.info("\nüëã Listener stopped by user")
        listener.stop()
    except Exception as e:
        logger.error(f"‚ùå Listener error: {e}")
        raise


if __name__ == "__main__":
    asyncio.run(run_telethon_listener())
